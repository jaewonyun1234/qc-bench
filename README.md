# qc-bench

Benchmark lab for 1D quantum systems on a grid (Infinite Square Well / Harmonic Oscillator / Double Well), comparing VQE/VQD ansatzes and the impact of shots + noise.

## Hamiltonian Variational Ansatz (HVA) in this project

This benchmark compares two VQE/VQD ansatz families:

* **`efficient_su2` (hardware-efficient):** generic layers of single-qubit rotations + entanglers.
* **`hva` (Hamiltonian Variational Ansatz):** physics-informed layers built from the Hamiltonian’s structure.

Goal:

> For simple 1D quantum systems (ISW / HO / Double Well), which ansatz gives the best first `k_states` energies for the least circuit cost, and how do shots + noise degrade performance?

---

## VQE reminder (what we optimize)

VQE/VQD searches for parameters $\theta$ that minimize the energy expectation value:
E(θ) = ⟨ψ(θ) | H | ψ(θ)⟩,  
where |ψ(θ)⟩ = U(θ) |ψ₀⟩.


Important: the state does **not** “naturally relax” to the ground state just because gates look like time evolution. Ground-state behavior comes from **variational minimization** (the optimizer), not physical cooling.

---

## What HVA is (one sentence)

**HVA is a variational ansatz built from exponentials of Hamiltonian components**, typically alternating “potential-like” and “kinetic-like” pieces.

---

## HVA design used here

After finite-difference discretization, the Hamiltonian splits naturally as:
H = T + V

* $T$: kinetic energy (finite-difference approximation to $-\frac{\hbar^2}{2m}\frac{d^2}{dx^2}$)
* $V$: potential energy (diagonal in the position/grid basis)

Plain HVA layer structure:

U(θ) =
  ∏ over ℓ = 1 to p of
    [ e^(−i α_ℓ V) · e^(−i β_ℓ T) ]


where each layer consists of:
- a potential evolution e^{-i α_ℓ V}
- followed by a kinetic evolution e^{-i β_ℓ T}


Each layer has **two parameters** $(\alpha_\ell,\beta_\ell)$, repeated for `reps = p` layers.

---

## Why HVA can be efficient (what “efficient” means here)

### 1) Parameter efficiency

Plain HVA uses **2 parameters per layer**, independent of qubit count. Hardware-efficient circuits often scale parameters with qubit count.

### 2) Physics-guided search directions

A small perturbation generated by $H_k$ gives:
e^{-i ε H_k} |ψ⟩ ≈ |ψ⟩ − i ε H_k |ψ⟩
so locally the ansatz explores directions like $-iH_k|\psi\rangle$. In HVA, the generators are physically meaningful operators ($T$, $V$), keeping the search structured.

### 3) Energy can change under HVA layers

Even though each factor looks like “time evolution,” energy is not conserved unless evolving under $H$ itself. If you apply a unitary generated by $H_k$ and measure energy of the full $H$:
E(θ) = ⟨ψ | e^{i θ H_k} H e^{-i θ H_k} | ψ⟩
and
(dE / dθ) evaluated at θ = 0 equals i ⟨ψ | [H_k, H] | ψ⟩
If $[H_k,H]\neq 0$, tuning $\theta$ can move energy up or down — enabling variational optimization.

---

## Symmetry note: parity for symmetric 1D potentials

For symmetric potentials (HO, symmetric double well, centered ISW), $V(x)=V(-x)$, so parity $P$ is a symmetry:
[H, P] = 0
Eigenstates can be chosen with definite parity, and low-lying states typically alternate parity:
$E_0$ even, $E_1$ odd, $E_2$ even, ...

If an ansatz/initialization is restricted to one symmetry sector, it cannot represent states in the other. By default, this benchmark avoids enforcing a single-parity restriction unless explicitly running sector experiments.

---

## Quickstart

```bash
python -m venv qc-bench-venv
source qc-bench-venv/bin/activate
pip install -e .
qc-bench --help
qc-bench configs/isw.yaml
```

If `qc-bench` is not on your PATH, use:

```bash
python -m qcbench.runner --help
python -m qcbench.runner configs/isw.yaml
```

By default, results append to `results/runs.parquet`. Use `--no-append` to overwrite:

```bash
qc-bench configs/isw.yaml --no-append
```

Then open `notebooks/01_figures.ipynb` to plot from the results table.

---

## Results table: `results/runs.parquet`

Each run appends **one row** to `results/runs.parquet` with run settings, grid info, circuit cost, energies, and error metrics.

### Column reference (full schema)

#### A) Run identifiers / settings

* `potential`: string. Potential name (e.g., `isw`, `ho`, `doublewell`).
* `ansatz`: string. Ansatz family (e.g., `efficient_su2`, `hva`).
* `reps`: int. Ansatz repetition count / depth parameter.
* `entanglement`: string. Entanglement pattern (passed through to ansatz builder).
* `backend`: string. `"statevector"` or `"noisy"`.
* `noise_strength`: float or NaN. Noise parameter used for `"noisy"` runs.
* `shots`: int or NaN. Shot count used for `"noisy"` runs.
* `seed`: int. Random seed for reproducibility.
* `k_states`: int. Number of eigenstates requested (produces energy columns `0..k_states-1`).

#### B) Grid / physical constants (from the discretized Hamiltonian)

* `L`: float. Domain length.
* `N`: int. Number of grid points (physical Hilbert dimension).
* `dx`: float. Grid spacing.
* `n_qubits`: int. Number of qubits used (so that $2^{n_qubits} \ge N$).
* `hilbert_dim`: int. Embedded qubit dimension ($2^{n_qubits}$).
* `x_min`, `x_max`: float. Min/max coordinates of the grid.
* `hbar`: float. $\hbar$ used in the kinetic term.
* `m`: float. Mass $m$ used in the kinetic term.

#### C) Circuit / operator cost

* `depth`: int. Circuit depth after construction (and transpilation if applicable in your workflow).
* `two_qubit_count`: int. Count of two-qubit gates (CX/CZ/SWAP/iSWAP/ECR/RXX/RYY/RZZ).
* `num_parameters`: int. Number of trainable circuit parameters.
* `num_pauli_terms`: int. Number of Pauli terms in the qubit Hamiltonian operator.

#### D) Optimization / runtime metadata

* `runtime_sec`: float. Wall-clock runtime for the VQD call.
* `eval_count`: int or NaN. Optimizer evaluation count (if available from metadata).
* `success`: bool. Whether the optimizer reports success.

#### E) Energies (per-state columns)

For `i = 0..k_states-1` (ground state is `i=0`):

* `E{i}`: **VQD estimated energy** for state `i`. (This is what you are benchmarking.)
* `E_exact{i}`: **Exact eigenvalue of the padded qubit Hamiltonian** (diagonalization of the final $2^{n}\times 2^{n}$ matrix).
* `E_err{i}`: **VQD error vs padded reference**, defined as `abs(E{i} - E_exact{i})`.

Also always included (grid diagonalization):

* `E_grid{i}`: **Grid energy** from diagonalizing the physical $N\times N$ Hamiltonian before padding.
* `E_pad_err{i}`: **Padding mismatch**, defined as `abs(E_exact{i} - E_grid{i})`.

Analytic (only when a closed-form exists and required params exist; e.g., ISW, HO with `omega`):

* `E_analytic{i}`: Analytic (continuous-space) textbook energy level.
* `E_analytic_err{i}`: Discretization error, defined as `abs(E_grid{i} - E_analytic{i})` (or `abs(E_exact{i} - E_analytic{i})` if grid energies were absent—which they are not in current runs).

#### F) Gap error (energy spacing diagnostic)

For `i = 0..k_states-2`:

* `gap_err_{i}`: error in the energy gap between states `i` and `i+1`:
  $$
  \left| (E_{i+1}-E_i) - (E^\text{exact}_{i+1}-E^\text{exact}_i) \right|.
  $$

#### G) Padding leakage diagnostics (how “physical” the padded eigenvectors are)

* `padding_leakage_max`: max leakage across the lowest `k_states` padded eigenvectors.
* `padding_leakage_mean`: mean leakage across the lowest `k_states` padded eigenvectors.

(Leakage = probability weight outside the original physical $N$-dimensional subspace when analyzing padded eigenvectors.)

---

## QC-Bench Metrics Reference (energies & errors)

QC-Bench tracks errors across three layers: **continuous physics**, **grid discretization**, and **quantum execution**.

### 1) `E_analytic{i}` — Theoretical (continuous) energy

* **Definition:** Closed-form energy in continuous space (no discretization).
* **Why it matters:** Physics “ground truth” (when it exists).
* **Example (HO):** $E_n = \hbar\omega(n+\tfrac{1}{2})$, so `E_analytic0` is $\tfrac{1}{2}\hbar\omega$.

### 2) `E_grid{i}` — Discretized grid energy

* **Definition:** Eigenvalue of the **physical** $N\times N$ grid Hamiltonian.
* **Why it matters:** Best possible answer your **grid model** can produce (even with a perfect quantum solver).

### 3) `E_exact{i}` — Padded qubit target energy

* **Definition:** Eigenvalue of the final **padded** $2^{n}\times 2^{n}$ Hamiltonian used for qubits.
* **Why it matters:** The **actual mathematical target** that VQD is trying to match.

### 4) `E_pad_err{i}` — Padding error

* **Definition:** `abs(E_exact{i} - E_grid{i})`
* **Why it matters:** Detects whether padding/penalties are cleanly preserving the low-energy physical spectrum.

### 5) `E_analytic_err{i}` — Discretization error

* **Definition:** `abs(E_grid{i} - E_analytic{i})` (when analytic energies exist)
* **Why it matters:** Tells you whether your grid resolution (`dx`, `N`, domain size) is sufficient.

### 6) `E{i}` and `E_err{i}` — Quantum algorithm output and error

* **`E{i}` definition:** The VQD-estimated energy for state `i`.
* **`E_err{i}` definition:** `abs(E{i} - E_exact{i})`
* **Why it matters:** Captures optimization limits + sampling + noise + ansatz expressibility.

### 7) `gap_err_{i}` — Energy gap error

* **Definition:**
| (E_{i+1} − E_i) − (E_exact_{i+1} − E_exact_i) |
* **Why it matters:** Excitation gaps are often more physically relevant than absolute energies.

---



